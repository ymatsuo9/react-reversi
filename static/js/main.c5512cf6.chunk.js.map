{"version":3,"sources":["index.js"],"names":["Square","props","className","onClick","isBlack","isWhite","Row","x","this","rowValues","rowIndex","renderSquare","React","Component","Board","i","squares","renderRow","Game","state","history","createSquares","stepNumber","blackIsNext","isPlaying","isSingleMode","cpuLevel","isCpuBlack","Math","random","blackIsPassed","undefined","Array","fill","map","y","slice","copy2dArray","length","selectableCells","getSelectableCells","selectedCell","values","selectableCell","select","putStone","selectCpuCell","selectCpuCellLv1","selectCpuCellLv2","selectedIndex","floor","size","get","from","keys","keyArray","cornerKeys","filter","key","centerKeys","targets","target","nextPlayer","setState","concat","current","blackStoneCount","whiteStoneCount","row","square","status","btnStartSingleLv1","btnStartSingleLv2","btnStartMulti","blackStoneCountMessage","String","whiteStoneCountMessage","pass","startSingle","startMulti","handleClick","setTimeout","passArea","document","querySelector","classList","add","remove","putCpuStone","input","output","push","blackSelectableCells","Map","whiteSelectableCells","candidateCells","column","appendSelectableCells","offset","x_start","max","y_start","step","abs","min","isBlackFound","isWhiteFound","isBlackToWhite","isWhiteToBlack","targetCells","candidateCell","mapObj","has","set","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.c5512cf6.chunk.js","sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nconst IS_BLACK = 0;\nconst IS_WHITE = 1;\n\nfunction Square(props) {\n  return (\n    <div className=\"square\" onClick={props.onClick}>\n      {props.isBlack ? <div className=\"stone black\"></div> : ''}\n      {props.isWhite ? <div className=\"stone white\"></div> : ''}\n    </div>\n  );\n}\n\nclass Row extends React.Component {\n  renderSquare(x) {\n    return (\n      <Square \n        isBlack={this.props.rowValues[x][0]}\n        isWhite={this.props.rowValues[x][1]}\n        onClick={() => this.props.onClick(x, this.props.rowIndex)}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        {this.renderSquare(0)}\n        {this.renderSquare(1)}\n        {this.renderSquare(2)}\n        {this.renderSquare(3)}\n        {this.renderSquare(4)}\n        {this.renderSquare(5)}\n        {this.renderSquare(6)}\n        {this.renderSquare(7)}\n      </div>\n    );\n  }\n}\n\nclass Board extends React.Component {\n  renderRow(i) {\n    return (\n      <Row \n        rowIndex={i}\n        rowValues={this.props.squares[i]}\n        onClick={this.props.onClick}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"board-row\">\n          {this.renderRow(0)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(1)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(2)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(3)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(4)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(5)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(6)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(7)}\n        </div>\n      </div>\n    );\n  }\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      history: [{\n        // horizontal(x): a-h\n        // vertical(y): 1-8\n        // (a1, a2, ..., a8) + (b1, ...) + ... + (..., h8)\n        // each value: [isBlack, isWhite]\n        squares: this.createSquares(),\n      }],\n      stepNumber: 0,\n      blackIsNext: true,\n      isPlaying: false,\n      isSingleMode: false,\n      cpuLevel: 2,\n      isCpuBlack: (Math.random() > 0.5),\n      blackIsPassed: undefined,\n    };\n  }\n\n  createSquares() {\n    const squares = Array(8).fill().map(()=>Array(8).fill().map(()=>([false, false])));\n    // d4: white\n    squares[3][3][1] = true;\n    // d5: black\n    squares[3][4][0] = true;\n    // e4: black\n    squares[4][3][0] = true;\n    // e5: white\n    squares[4][4][1] = true;\n    return squares;\n  }\n\n  handleClick(x, y) {\n    if (!this.state.isPlaying) {\n      return;\n    }\n\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\n    const current = history[history.length - 1];\n    let squares = copy2dArray(current.squares);\n    if (squares[y][x][IS_BLACK] || squares[y][x][IS_WHITE]) {\n      return;\n    }\n\n    if (this.state.isSingleMode &&\n      (this.state.isCpuBlack === this.state.blackIsNext)) {\n        // CPU is thinking.\n        return;\n      }\n\n    const selectableCells = getSelectableCells(squares, this.state.blackIsNext);\n    let selectedCell = undefined;\n    for (const selectableCell of selectableCells.values()) {\n      if (selectableCell.select.x === x && selectableCell.select.y === y) {\n        selectedCell = selectableCell;\n        break;\n      }\n    }\n    if (typeof selectedCell === 'undefined') {\n      return;\n    }\n\n    this.putStone(history, squares, selectedCell);\n  }\n\n  putCpuStone() {\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\n    const current = history[history.length - 1];\n    let squares = copy2dArray(current.squares);\n\n    let selectedCell = this.selectCpuCell(this.state.cpuLevel, squares, this.state.blackIsNext);\n    \n    this.putStone(history, squares, selectedCell);\n  }\n  \n  selectCpuCell(cpuLevel, squares, blackIsNext) {\n    let selectedCell = undefined;\n    const selectableCells = getSelectableCells(squares, blackIsNext);\n\n    if (cpuLevel === 1) {\n      selectedCell = this.selectCpuCellLv1(selectableCells);\n    } else if (cpuLevel === 2) {\n      selectedCell = this.selectCpuCellLv2(selectableCells);\n    }\n\n    return selectedCell;\n  }\n\n  selectCpuCellLv1(selectableCells) {\n    const selectedIndex = Math.floor(Math.random() * selectableCells.size);\n    return selectableCells.get(Array.from(selectableCells.keys())[selectedIndex]);\n  }\n\n  selectCpuCellLv2(selectableCells) {\n    const keyArray = Array.from(selectableCells.keys());\n    const cornerKeys = keyArray.filter(function(key) {\n      return (\n        (key === '0-0') || (key === '0-7') ||\n        (key === '7-0') || (key === '7-7')\n      );\n    });\n\n    if (cornerKeys.length > 0) {\n      const selectedIndex = Math.floor(Math.random() * cornerKeys.length);\n      return selectableCells.get(cornerKeys[selectedIndex]);\n    }\n    \n    const centerKeys = keyArray.filter(function(key) {\n      return (\n        (key !== '0-1') && (key !== '1-0') && (key !== '1-1') &&\n        (key !== '0-6') && (key !== '1-6') && (key !== '1-7') &&\n        (key !== '6-0') && (key !== '6-1') && (key !== '7-1') &&\n        (key !== '6-6') && (key !== '6-7') && (key !== '7-6')\n      );\n    });\n\n    if (centerKeys.length > 0) {\n      const selectedIndex = Math.floor(Math.random() * centerKeys.length);\n      return selectableCells.get(centerKeys[selectedIndex]);\n    }\n\n    return this.selectCpuCellLv1(selectableCells);\n  }\n\n  putStone(history, squares, selectedCell) {\n    let x = selectedCell.select.x;\n    let y = selectedCell.select.y;\n\n    if (this.state.blackIsNext) {\n      squares[y][x][IS_BLACK] = true;\n      for (const target of selectedCell.targets) {\n        squares[target[1]][target[0]][IS_BLACK] = true;\n        squares[target[1]][target[0]][IS_WHITE] = false;\n      }\n    } else {\n      squares[y][x][IS_WHITE] = true;\n      for (const target of selectedCell.targets) {\n        squares[target[1]][target[0]][IS_BLACK] = false;\n        squares[target[1]][target[0]][IS_WHITE] = true;\n      }\n    }\n\n    let nextPlayer = !this.state.blackIsNext;\n    let isPlaying = true;\n    let blackIsPassed = undefined;\n    const selectableCellsOpposite = getSelectableCells(squares, nextPlayer);\n    if (selectableCellsOpposite.size === 0) {\n      // skip\n      nextPlayer = !nextPlayer;\n\n      const selectableCellsMine = getSelectableCells(squares, nextPlayer);\n      if (selectableCellsMine.size === 0) {\n        // game end\n        nextPlayer = undefined;\n        isPlaying = false;\n      } else {\n        blackIsPassed = !this.state.blackIsNext;\n      }\n    }\n\n    this.setState({\n      history: history.concat([{\n        squares: squares,\n      }]),\n      stepNumber: history.length,\n      blackIsNext: nextPlayer,\n      isPlaying: isPlaying,\n      blackIsPassed: blackIsPassed,\n    });\n  }\n\n  startSingle(cpuLevel) {\n    let isCpuBlack = (Math.random() > 0.5);\n\n    this.setState({\n      history: [{\n        squares: this.createSquares(),\n      }],\n      stepNumber: 0,\n      blackIsNext: true,\n      isPlaying: true,\n      isSingleMode: true,\n      cpuLevel: cpuLevel,\n      isCpuBlack: isCpuBlack,\n      blackIsPassed: undefined,\n    })\n  }\n\n  startMulti() {\n    this.setState({\n      history: [{\n        squares: this.createSquares(),\n      }],\n      stepNumber: 0,\n      blackIsNext: true,\n      isPlaying: true,\n      isSingleMode: false,\n      cpuLevel: 1,\n      isCpuBlack: false,\n      blackIsPassed: undefined,\n    })\n  }\n\n  render() {\n    const history = this.state.history;\n    const current = history[this.state.stepNumber];\n\n    let blackStoneCount = 0;\n    let whiteStoneCount = 0;\n    for (const row of current.squares) {\n      for (const square of row) {\n        if (square[IS_BLACK]) {\n          blackStoneCount++;\n        } else if (square[IS_WHITE]) {\n          whiteStoneCount++;\n        }\n      }\n    }\n    let blackStoneCountMessage = 'Black: ' + String(blackStoneCount);\n    let whiteStoneCountMessage = 'White: ' + String(whiteStoneCount);\n\n    let status;\n    let btnStartSingleLv1;\n    let btnStartSingleLv2;\n    let btnStartMulti;\n    let pass = (\n      <div className=\"pass\">Pass</div>\n    );\n    if (typeof this.state.blackIsNext === 'undefined') {\n      if (blackStoneCount > whiteStoneCount) {\n        status = 'Winner: Black';\n      } else if (blackStoneCount < whiteStoneCount) {\n        status = 'Winner: White';\n      } else {\n        status = 'Draw';\n      }\n    } else {\n      status = 'Next player: ' + (this.state.blackIsNext ? 'Black' : 'White') + ((this.state.isSingleMode && (this.state.isCpuBlack === this.state.blackIsNext) ? (' (CPU)') : ''));\n    }\n\n    if (!this.state.isPlaying) {\n      btnStartSingleLv1 = (\n        <button className='controller' onClick={() => this.startSingle(1)}>Start (CPU Lv1)</button>\n      );  \n      btnStartSingleLv2 = (\n        <button className='controller' onClick={() => this.startSingle(2)}>Start (CPU Lv2)</button>\n      );  \n      btnStartMulti = (\n        <button className='controller' onClick={() => this.startMulti()}>Start (Multi)</button>\n      );  \n    }\n\n    return (\n      <div className=\"game\">\n        <div className=\"game-board\">\n          <Board \n            squares={current.squares}\n            onClick={(x, y) => this.handleClick(x, y)}\n          />\n          <div>{pass}</div>\n        </div>\n        <div className=\"game-info\">\n          <div>{status}</div>\n          <div>{blackStoneCountMessage}</div>\n          <div>{whiteStoneCountMessage}</div>\n          <div>{btnStartSingleLv1}</div>\n          <div>{btnStartSingleLv2}</div>\n          <div>{btnStartMulti}</div>\n        </div>\n      </div>\n    );\n  }\n\n  componentDidUpdate() {\n    if (typeof this.state.blackIsPassed !== 'undefined') {\n      setTimeout((() => {\n        const passArea = document.querySelector('.pass');\n        passArea.classList.add('pass-popup');\n\n        setTimeout(() => {\n          passArea.classList.remove('pass-popup');\n        }, 1000);\n        // alert((!this.state.blackIsNext ? 'Black' : 'White') + ' Pass');\n      }), 300);\n    }\n\n    if (this.state.isSingleMode &&\n      (this.state.isCpuBlack === this.state.blackIsNext)) {\n        setTimeout((() => {this.putCpuStone();}), 1000);\n      }\n  }\n}\n\nSquare.propTypes = {\n  isBlack: PropTypes.bool,\n  isWhite: PropTypes.bool,\n  onClick: PropTypes.func,\n};\n\nRow.propTypes = {\n  rowIndex: PropTypes.number,\n  rowValues: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.bool)),\n  onClick: PropTypes.func,\n};\n\nBoard.propTypes = {\n  squares: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.bool))),\n  onClick: PropTypes.func,\n};\n\n// ========================================\n\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);\n\nfunction copy2dArray(input) {\n  const output = [];\n  for (const row of input) {\n    output.push([...row]);\n  }\n  return output;\n}\n\nfunction getSelectableCells(squares, blackIsNext) {\n  let blackSelectableCells = new Map();\n  let whiteSelectableCells = new Map();\n\n  let candidateCells = [];\n\n  // row direction\n  for (let row = 0; row < 8; row++) {\n    // left to right\n    candidateCells = [];\n    for (let column = 0; column < 8; column++) {\n      candidateCells.push({x: column, y: row});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n\n    // right to left\n    candidateCells = [];\n    for (let column = 7; column >= 0; column--) {\n      candidateCells.push({x: column, y: row});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n  }\n\n  // column direction\n  for (let column = 0; column < 8; column++) {\n    // top to bottom\n    candidateCells = [];\n    for (let row = 0; row < 8; row++) {\n      candidateCells.push({x: column, y: row});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n\n    // bottom to top\n    candidateCells = [];\n    for (let row = 7; row >= 0; row--) {\n      candidateCells.push({x: column, y: row});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n  }\n\n  // top-left to bottom-right direction\n  for (let offset = -5; offset <= 5; offset++) {\n    let x_start = Math.max(0, offset);\n    let y_start = Math.max(0, -offset);\n\n    // top to bottom\n    candidateCells = [];\n    for (let step = 0; step < (8 - Math.abs(offset)); step++) {\n      candidateCells.push({x: (x_start + step), y: (y_start + step)});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n\n    // bottom to top\n    candidateCells = [];\n    for (let step = (7 - Math.abs(offset)); step >= 0; step--) {\n      candidateCells.push({x: (x_start + step), y: (y_start + step)});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n  }\n  \n  // top-right to bottom-left direction\n  for (let offset = -5; offset <= 5; offset++) {\n    let x_start = 7 + Math.min(0, offset);\n    let y_start = Math.max(0, offset);\n\n    // top to bottom\n    candidateCells = [];\n    for (let step = 0; step < (8 - Math.abs(offset)); step++) {\n      candidateCells.push({x: (x_start - step), y: (y_start + step)});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n\n    // bottom to top\n    candidateCells = [];\n    for (let step = (7 - Math.abs(offset)); step >= 0; step--) {\n      candidateCells.push({x: (x_start - step), y: (y_start + step)});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n  }\n  \n  if (blackIsNext) {\n    return blackSelectableCells;\n  } else {\n    return whiteSelectableCells;\n  }\n}\n\nfunction appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells) {\n  let isBlackFound = false;\n  let isWhiteFound = false;\n  let isBlackToWhite = false;\n  let isWhiteToBlack = false;\n  let targetCells = [];\n\n  for (let candidateCell of candidateCells) {\n    const column = candidateCell.x;\n    const row = candidateCell.y;\n\n    if (squares[row][column][IS_BLACK]) {\n      isBlackFound = true;\n      if (isWhiteFound) {\n        isWhiteToBlack = true;\n        isWhiteFound = false;\n        isBlackToWhite = false;\n        targetCells = [];\n      }\n      if (isWhiteToBlack) {\n        targetCells.push([column, row]);\n      }\n    } else if (squares[row][column][IS_WHITE]) {\n      isWhiteFound = true;\n      if (isBlackFound) {\n        isBlackToWhite = true;\n        isBlackFound = false;\n        isWhiteToBlack = false;\n        targetCells = [];\n      }\n      if (isBlackToWhite) {\n        targetCells.push([column, row]);\n      }\n    } else {\n      if (isBlackToWhite || isWhiteToBlack) {\n        const key = String(column) + '-' + String(row);\n        let mapObj = undefined;\n        if (isBlackToWhite) {\n          mapObj = blackSelectableCells;\n        } else {\n          mapObj = whiteSelectableCells;\n        }\n        if (mapObj.has(key)) {\n          mapObj.get(key).targets.push(...targetCells);\n        } else {\n          mapObj.set(key, {select: candidateCell, targets: targetCells});\n        }\n      }\n      isBlackFound = false;\n      isWhiteFound = false;\n      isBlackToWhite = false;\n      isWhiteToBlack = false;\n      targetCells = [];\n    }\n  }\n}\n"],"sourceRoot":""}