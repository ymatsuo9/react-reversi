{"version":3,"sources":["index.js"],"names":["Square","props","className","onClick","isBlack","isWhite","Row","x","this","rowValues","rowIndex","renderSquare","React","Component","Board","i","squares","renderRow","Game","state","history","createSquares","stepNumber","blackIsNext","Array","fill","map","y","slice","input","output","row","push","copy2dArray","length","selectableCells","getSelectableCells","selectedCell","undefined","values","selectableCell","select","targets","target","nextPlayer","size","setState","concat","current","blackStoneCount","whiteStoneCount","square","status","move","blackStoneCountMessage","String","whiteStoneCountMessage","restart","handleClick","blackSelectableCells","Map","whiteSelectableCells","candidateCells","column","appendSelectableCells","offset","x_start","Math","max","y_start","step","abs","min","isBlackFound","isWhiteFound","isBlackToWhite","isWhiteToBlack","targetCells","candidateCell","key","mapObj","has","get","set","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.e45d621e.chunk.js","sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nconst IS_BLACK = 0;\nconst IS_WHITE = 1;\n\nfunction Square(props) {\n  return (\n    <div className=\"square\" onClick={props.onClick}>\n      {props.isBlack ? <div className=\"stone black\"></div> : ''}\n      {props.isWhite ? <div className=\"stone white\"></div> : ''}\n    </div>\n  );\n}\n\nclass Row extends React.Component {\n  renderSquare(x) {\n    return (\n      <Square \n        isBlack={this.props.rowValues[x][0]}\n        isWhite={this.props.rowValues[x][1]}\n        onClick={() => this.props.onClick(x, this.props.rowIndex)}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        {this.renderSquare(0)}\n        {this.renderSquare(1)}\n        {this.renderSquare(2)}\n        {this.renderSquare(3)}\n        {this.renderSquare(4)}\n        {this.renderSquare(5)}\n        {this.renderSquare(6)}\n        {this.renderSquare(7)}\n      </div>\n    );\n  }\n}\n\nclass Board extends React.Component {\n  renderRow(i) {\n    return (\n      <Row \n        rowIndex={i}\n        rowValues={this.props.squares[i]}\n        onClick={this.props.onClick}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"board-row\">\n          {this.renderRow(0)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(1)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(2)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(3)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(4)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(5)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(6)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderRow(7)}\n        </div>\n      </div>\n    );\n  }\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      history: [{\n        // horizontal(x): a-h\n        // vertical(y): 1-8\n        // (a1, a2, ..., a8) + (b1, ...) + ... + (..., h8)\n        // each value: [isBlack, isWhite]\n        squares: this.createSquares(),\n      }],\n      stepNumber: 0,\n      blackIsNext: true,\n    };\n  }\n\n  createSquares() {\n    const squares = Array(8).fill().map(()=>Array(8).fill().map(()=>([false, false])));\n    // d4: white\n    squares[3][3][1] = true;\n    // d5: black\n    squares[3][4][0] = true;\n    // e4: black\n    squares[4][3][0] = true;\n    // e5: white\n    squares[4][4][1] = true;\n    return squares;\n  }\n\n  handleClick(x, y) {\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\n    const current = history[history.length - 1];\n    let squares = copy2dArray(current.squares);\n    if (squares[y][x][IS_BLACK] || squares[y][x][IS_WHITE]) {\n      return;\n    }\n\n    const selectableCells = getSelectableCells(squares, this.state.blackIsNext);\n    let selectedCell = undefined;\n    for (const selectableCell of selectableCells.values()) {\n      if (selectableCell.select.x === x && selectableCell.select.y === y) {\n        selectedCell = selectableCell;\n        break;\n      }\n    }\n    if (typeof selectedCell === 'undefined') {\n      return;\n    }\n\n    if (this.state.blackIsNext) {\n      squares[y][x][IS_BLACK] = true;\n      for (const target of selectedCell.targets) {\n        squares[target[1]][target[0]][IS_BLACK] = true;\n        squares[target[1]][target[0]][IS_WHITE] = false;\n      }\n    } else {\n      squares[y][x][IS_WHITE] = true;\n      for (const target of selectedCell.targets) {\n        squares[target[1]][target[0]][IS_BLACK] = false;\n        squares[target[1]][target[0]][IS_WHITE] = true;\n      }\n    }\n\n    let nextPlayer = !this.state.blackIsNext;\n    const selectableCellsOpposite = getSelectableCells(squares, nextPlayer);\n    if (selectableCellsOpposite.size === 0) {\n      // skip\n      nextPlayer = !nextPlayer;\n\n      const selectableCellsMine = getSelectableCells(squares, nextPlayer);\n      if (selectableCellsMine.size === 0) {\n        // game end\n        nextPlayer = undefined;\n      }\n    }\n\n    this.setState({\n      history: history.concat([{\n        squares: squares,\n      }]),\n      stepNumber: history.length,\n      blackIsNext: nextPlayer,\n    });\n  }\n\n  restart() {\n    this.setState({\n      history: [{\n        squares: this.createSquares(),\n      }],\n      stepNumber: 0,\n      blackIsNext: true,\n    })\n  }\n\n  render() {\n    const history = this.state.history;\n    const current = history[this.state.stepNumber];\n\n    let blackStoneCount = 0;\n    let whiteStoneCount = 0;\n    for (const row of current.squares) {\n      for (const square of row) {\n        if (square[IS_BLACK]) {\n          blackStoneCount++;\n        } else if (square[IS_WHITE]) {\n          whiteStoneCount++;\n        }\n      }\n    }\n    let blackStoneCountMessage = 'Black: ' + String(blackStoneCount);\n    let whiteStoneCountMessage = 'White: ' + String(whiteStoneCount);\n\n    let status;\n    let move;\n    if (typeof this.state.blackIsNext === 'undefined') {\n      if (blackStoneCount > whiteStoneCount) {\n        status = 'Winner: Black';\n      } else if (blackStoneCount < whiteStoneCount) {\n        status = 'Winner: White';\n      } else {\n        status = 'Draw';\n      }\n      move = (\n        <button onClick={() => this.restart()}>restart</button>\n      );  \n    } else {\n      status = 'Next player: ' + (this.state.blackIsNext ? 'Black' : 'White');\n    }\n\n    return (\n      <div className=\"game\">\n        <div className=\"game-board\">\n          <Board \n            squares={current.squares}\n            onClick={(x, y) => this.handleClick(x, y)}\n          />\n        </div>\n        <div className=\"game-info\">\n          <div>{status}</div>\n          <div>{blackStoneCountMessage}</div>\n          <div>{whiteStoneCountMessage}</div>\n          <div>{move}</div>\n        </div>\n      </div>\n    );\n  }\n}\n\nSquare.propTypes = {\n  isBlack: PropTypes.bool,\n  isWhite: PropTypes.bool,\n  onClick: PropTypes.func,\n};\n\nRow.propTypes = {\n  rowIndex: PropTypes.number,\n  rowValues: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.bool)),\n  onClick: PropTypes.func,\n};\n\nBoard.propTypes = {\n  squares: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.bool))),\n  onClick: PropTypes.func,\n};\n\n// ========================================\n\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);\n\nfunction copy2dArray(input) {\n  const output = [];\n  for (const row of input) {\n    output.push([...row]);\n  }\n  return output;\n}\n\nfunction getSelectableCells(squares, blackIsNext) {\n  let blackSelectableCells = new Map();\n  let whiteSelectableCells = new Map();\n\n  let candidateCells = [];\n\n  // row direction\n  for (let row = 0; row < 8; row++) {\n    // left to right\n    candidateCells = [];\n    for (let column = 0; column < 8; column++) {\n      candidateCells.push({x: column, y: row});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n\n    // right to left\n    candidateCells = [];\n    for (let column = 7; column >= 0; column--) {\n      candidateCells.push({x: column, y: row});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n  }\n\n  // column direction\n  for (let column = 0; column < 8; column++) {\n    // top to bottom\n    candidateCells = [];\n    for (let row = 0; row < 8; row++) {\n      candidateCells.push({x: column, y: row});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n\n    // bottom to top\n    candidateCells = [];\n    for (let row = 7; row >= 0; row--) {\n      candidateCells.push({x: column, y: row});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n  }\n\n  // top-left to bottom-right direction\n  for (let offset = -5; offset <= 5; offset++) {\n    let x_start = Math.max(0, offset);\n    let y_start = Math.max(0, -offset);\n\n    // top to bottom\n    candidateCells = [];\n    for (let step = 0; step < (8 - Math.abs(offset)); step++) {\n      candidateCells.push({x: (x_start + step), y: (y_start + step)});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n\n    // bottom to top\n    candidateCells = [];\n    for (let step = (7 - Math.abs(offset)); step >= 0; step--) {\n      candidateCells.push({x: (x_start + step), y: (y_start + step)});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n  }\n  \n  // top-right to bottom-left direction\n  for (let offset = -5; offset <= 5; offset++) {\n    let x_start = 7 + Math.min(0, offset);\n    let y_start = Math.max(0, offset);\n\n    // top to bottom\n    candidateCells = [];\n    for (let step = 0; step < (8 - Math.abs(offset)); step++) {\n      candidateCells.push({x: (x_start - step), y: (y_start + step)});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n\n    // bottom to top\n    candidateCells = [];\n    for (let step = (7 - Math.abs(offset)); step >= 0; step--) {\n      candidateCells.push({x: (x_start - step), y: (y_start + step)});\n    }\n    appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells);\n  }\n  \n  if (blackIsNext) {\n    return blackSelectableCells;\n  } else {\n    return whiteSelectableCells;\n  }\n}\n\nfunction appendSelectableCells(squares, blackSelectableCells, whiteSelectableCells, candidateCells) {\n  let isBlackFound = false;\n  let isWhiteFound = false;\n  let isBlackToWhite = false;\n  let isWhiteToBlack = false;\n  let targetCells = [];\n\n  for (let candidateCell of candidateCells) {\n    const column = candidateCell.x;\n    const row = candidateCell.y;\n\n    if (squares[row][column][IS_BLACK]) {\n      isBlackFound = true;\n      if (isWhiteFound) {\n        isWhiteToBlack = true;\n        isWhiteFound = false;\n        isBlackToWhite = false;\n      }\n      if (isWhiteToBlack) {\n        targetCells.push([column, row]);\n      }\n    } else if (squares[row][column][IS_WHITE]) {\n      isWhiteFound = true;\n      if (isBlackFound) {\n        isBlackToWhite = true;\n        isBlackFound = false;\n        isWhiteToBlack = false;\n      }\n      if (isBlackToWhite) {\n        targetCells.push([column, row]);\n      }\n    } else {\n      if (isBlackToWhite || isWhiteToBlack) {\n        const key = String(column) + '-' + String(row);\n        let mapObj = undefined;\n        if (isBlackToWhite) {\n          mapObj = blackSelectableCells;\n        } else {\n          mapObj = whiteSelectableCells;\n        }\n        if (mapObj.has(key)) {\n          mapObj.get(key).targets.push(...targetCells);\n        } else {\n          mapObj.set(key, {select: candidateCell, targets: targetCells});\n        }\n      }\n      isBlackFound = false;\n      isWhiteFound = false;\n      isBlackToWhite = false;\n      isWhiteToBlack = false;\n      targetCells = [];\n    }\n  }\n}\n"],"sourceRoot":""}